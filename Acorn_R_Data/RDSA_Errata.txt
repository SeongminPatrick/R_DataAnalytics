-----------------------------------------------------
이제 R에서 완전 영구 스택의 구현을 이해해 봅시다.
완전 영구 스택 데이터 구조의 구현은 Shawn T. O'Neil이 기고 한 rstackdeque cran 패키지에서 사용할 수 있습니다. R에서는 부작용없는 인터페이스 함수를 사용하여 환경 변수를 사용하여 변경 가능성을 보장 할 수 있습니다.

이 패키지에서 스택은 정렬되지 않은 링크 된 목록을 사용하여 구현되며 각 노드 (목록)는 데이터 요소와 다음 노드에 대한 참조로 구성됩니다. 이러한 스택은 S3 스택 객체를 사용하여 액세스 할 수있는 S3 객체입니다.

5 개의 문자 요소를 가진 스택을 생각해 봅시다 :

전통적인 push 함수와 유사하게, insert_top은 맨 위에 새로운 요소가있는 스택을 반환하는 데 사용됩니다. 여기서 새 스택을 만드는 대신 b의 헤드 요소는 o 요소쪽으로 향하게됩니다.이 요소는 그림 10.1과 같이 스택 a 방향으로 향하게됩니다.

스택 (팝)에서 맨 위 요소를 철회하는 경우에는 without_top 함수가 사용됩니다. insert_top과 유사하게 기본 스택은 파괴적으로 업데이트되지 않지만 스택 c의 포인터는 그림 10.1과 같이 하나의 요소만큼 오른쪽으로 이동합니다.



peek_top 함수는 스택 맨 위에있는 데이터 요소를 반환하는 데 사용됩니다.



다음 그림 10.1은 R의 완전 영구 스택 구현을 보여줍니다.

그림 10.1 : 다양한 유형의 삽입 또는 삭제 작업을 기반으로하는 완전 영구 스택 작업 (a)는 링크 된 목록의 경우와 마찬가지로 다른 문자에 연결된 각 문자의 5 개 문자 스택을 나타냅니다. (b)는 스택 (a) 위에 새로운 요소 o를 삽입 한 후의 스택을 나타냅니다. (c)는 스택 (a)의 상부 요소를 제거한 후의 스택을 나타낸다. (d)는 스택의 최상위 요소 (a)가있는 문자 벡터를 나타냅니다.

----
대기열은 데이터 구조의 FIFO (First In First Out) 형식으로, 삽입은 동일한 순서로 삭제됩니다. 대기열을 구현하는 한 가지 방법은 끝 (맨 위)의 요소를 삽입하고 반대쪽 끝 (대기열의 맨 아래)에서 요소를 삭제하는 것입니다. 일부 대기열은 양쪽 끝에서 삽입 및 삭제를 지원합니다. 이것들은 deques 또는 double-ended 대기열이라고합니다. 큐와 deques는 Breadth-first search (BFS) 알고리즘에서 사용됩니다. 스택과 비슷하게, 이상적으로 삽입, 제거 및 엿보기 작업은 최악의 시나리오에 대해 O (1)의 점근선을 사용하는 데 거의 시간이 필요하지 않습니다. 따라서, 최악의 시나리오에서, n 개의 삽입 또는 제거는 O (n)의 점근선을 가지며, O (1)의 각 연산의 평균 점근선을 제공한다.

이제 Shawn T. O'Neil이 제공 한 rstackdeque cran 패키지를 사용하여 R에서의 빠르고 영구적이며 천천히 지속되는 대기열 및 deques의 구현을 이해합시다.


----
신속하고 영구적 인 대기열은 주로 재귀 적으로 정의 된 작업과 지연된 평가에 의해 관리됩니다. 즉, 이러한 대기열은 첫 번째 요소에 즉시 액세스 할 수 있고 나머지 요소가 지연되어 평가되는 지연 목록을 사용하여 구현됩니다. 액세스 할 때마다 요소 만 평가되는 재귀 대형 목록의 경우 유용합니다.

빠른 지속성 큐를 구현하는 R 함수는 rpqueue입니다. 마지막 목록은 l, r, lh입니다. 여기에서 요소는 큐의 뒤쪽에 삽입되고 제거되거나 큐의 맨 앞에 서 삭제됩니다. 즉, 새로운 요소의 삽입은 r 목록의 맨 위에서 일어나고 기존 요소의 삭제는 l 목록의 앞에서 발생합니다. 이러한 지연 목록은 rstacks로 구현되며 모든 노드의 nextnode 요소는 delayedAssign 함수를 사용하여 할당됩니다. 이것들은 첫 번째 평가에서 나중에 메모됩니다.

전통적으로, queue는 l stack의 길이가 적어도 r stack의 길이와 같도록 보장하려고 시도한다. 그러나, 임의의 삽입 또는 삭제 동작 중에, 길이는 방해 받는다. r 스택의 길이는 삽입시 증가하고 l 스택의 길이는 삭제시 감소합니다. 이러한 작업을 게시하면 l 스택의 마지막 요소에 l 스택을 추가하여 l 및 r 스택을 다시 조정합니다. 이 재조정은 l 및 r 스택 내에서 발생하는 삽입 또는 삭제의 종류에 대해 O (1)의 점근선을 필요로합니다. 재조정시 스택 1의 데이터가 할당됩니다. 그 다음에 각각의 삽입 또는 삭제에 대해, lhat 스택이 비게 될 때까지 lhat의 요소는 하나씩 제거됩니다. 일단 lhat이 비게되면, l과 r 스택의 길이가 계산되고 요소가 다시 조정되어 다시 반복 시간이 지연됩니다.

예제를 사용하여 완전 영속 대기열의 작동을 이해합시다. 길이가 4 인 영구 대기열을 고려하십시오.

왼쪽 스택 l에는 "p", "q"및 "r"요소가 할당되고 오른쪽 스택 "r"에는 요소 "s"가 할당되고 스택 스택에는 "q"및 "r"요소가 할당됩니다. 다음 그림 10.2는 삽입 및 삭제 작업에 기반한 영구 대기열 작업을 보여줍니다. 삽입 작업은 insert_back 함수를 사용하여 수행되고 삭제 작업은 without_front 함수를 사용하여 수행됩니다.

그림 10.2 : 다양한 유형의 삽입 또는 삭제 작업을 기반으로하는 완전 영구 대기열의 작업 (a)는 새 영구 대기열을 나타냅니다. (b)는 큐 (a)의 뒤쪽에 새로운 요소 "t"를 삽입 한 후의 큐를 나타냅니다. (c)는 큐 (b)에서 front 요소를 삭제 한 후의 큐를 나타냅니다. (d)는 큐 (c)의 뒤쪽에 새로운 요소 "v"를 삽입 한 후 큐를 나타냅니다. (e)는 큐 (d)의 뒤쪽에 새로운 요소 "w"를 삽입 한 후 큐를 나타냅니다. (f)는 큐 (e)의 앞에서 요소를 삭제 한 후의 큐를 나타냅니다.


----
대기열은 왼쪽 스택과 오른쪽 스택의 두 스택으로 구현됩니다. 왼쪽 스택은 삭제 작업에 사용되는 큐의 첫 번째 요소 집합을 보유하고 오른쪽 스택은 삽입 작업에 사용되는 큐의 마지막 요소 집합을 보유합니다. 반면에, 왼쪽 스택은 삽입을 위해 그리고 오른쪽 스택은 삭제를 위해 사용될 수 있습니다. 오른쪽 스택은 그림 10.3에서와 같이 역순으로 요소를 보유합니다.

대기열은 그림 10.3과 그림 10.4에서와 같이 왼쪽 대기열과 오른쪽 대기열로 분할됩니다. insert_front 또는 insert_back 함수를 사용하여 요소는 각각 큐의 앞이나 뒤에 삽입됩니다.

마찬가지로 요소는 또한 without_front 또는 without_back 함수를 사용하여 큐의 앞이나 뒤에 삭제 될 수 있습니다.

다음 그림 10.3과 그림 10.4는 R에서 천천히 지속되는 대기열의 구현을 설명합니다.

그림 10.3 : 다양한 유형의 삽입 또는 삭제 작업을 기반으로 천천히 지속되는 대기열 및 dequeus 작업. (a)는 왼쪽 및 오른쪽 스택이있는 대기열을 나타냅니다. (b)는 큐 (a)의 선두에 새로운 요소 "o"를 삽입 한 후의 큐를 나타낸다.

그림 10.3은 a로 전달 된 초기 7 개의 문자 요소를 얼마나 천천히 지속하는 대기열에 저장 하는지를 보여줍니다. 큐의 왼쪽은 $ l을 사용하여 추출 할 수 있고 큐의 오른쪽은 $ r을 사용하여 추출 할 수 있습니다. 이미지의 b 부분은 insert_front 함수 (a, c ( "o"))를 사용하여 요소 o가 추가 될 때 기능 대기열 a가 업데이트되는 방법을 보여줍니다.

그림 10.4 : (c)는 새로운 요소 w를 큐 (a)의 뒤에 삽입 한 후의 큐를 나타냅니다. (d)는 대기열 (a)에서 front 요소를 삭제 한 후의 대기열을 나타냅니다. (e)는 큐 (a)에서 마지막 요소를 삭제 한 후의 큐를 나타냅니다.

현재 구현에서는 그림 10.4와 같이 모든 삽입 또는 삭제 후 다시 균형을 조정하는 이중 종료 대기열이 사용됩니다. 왼쪽과 오른쪽 스택 모두 매우 불균형하게되면, 둘 다 먼저 목록으로 분해 된 다음 두 개의 거의 균형 잡힌 스택으로 다시 구성됩니다.

----
기능적 프로그래밍은 학문적 목적 외에도 우주 항공, 통신 및 로봇과 같은 광범위한 산업 애플리케이션에 사용됩니다. 하스켈, 스칼라, F #과 같은 순수 함수형 언어가

산업. 불변성과 지속성의 속성은 이러한 데이터 구조를 투명성, 시뮬레이션 및 효율성면에서보다 강력하게 만듭니다. 현재 챕터는 주로 기능적 데이터 구조, 지연 평가의 개념 및 기능적 스택과 기능적 큐의 상세한 분석을 다룹니다.


-----------------------------------------------------
Chapter 10

functional data structure	함수적 데이터 구조
functional programming		함수형 프로그래밍

Lazy evaluation		지연 평가
closure function	클로저 함수



-----------------------------------------------------
접근 방법  -->  접근법

<그림시작>
<그림끝>

-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------
Chapter 1 to 2.

https://www.packtpub.com/books/content/support/26217

-----------------------------------------------------
Chapter 1

1. page 21 line 1

   from 1 to 7  -->  1 to 6

-----------------------------------------------------
Chapter 2

2. page 37 line 5 

   dplyr, sqldf, dplyr  --->  dplyr : duplicated

3. page 38 line 9

   each expression 100 times  -->  1,000 times

4. page 48 line 5

    faster than g(n)  -->  slower than

5. Page 49 figure 2.10 / Loop / Rule definition

   n*O(g1(n))  -->  n*O(g(n)) 

-----------------------------------------------------
-----------------------------------------------------
-----------------------------------------------------
Chapter 3

** page 64 line 14

   ## Categorical Matrix  -->  Character Matrix (see line 1)

** page 74 line 4 from bottom

   findItem(llist$nextnode, item, size, itemFound)  # runtime error
   size  -->  pos

-----------------------------------------------------
Chapter 4

** page 84 line 1 from bottom

   Table 4.1 ...... for queue  -->  stack


** page 90 line 9 from bottom

   topVal = ...  -->  top = function()

   (see page 89 line 7. you define this function in class : top = function(){})


** page 91 line 12

   a$topVal  -->  link_stack_ex$top  (see the previous issue)


** page 96 line 7 from bottom

   function(qSize, ...)     # runtime error
   -->  
   function(qSize=100, ...)   


** page 99 line 12 from bottom

   cat("Empty Stack!")  -->  cat("Empty Queue!")


** page 102

   (1)
   Adict<-setRefClass(fields = list(           # runtime error

   -->
   Adict <- setRefClass(Class = "Dictionary",
        fields = list(

   (2)
   # remove value with following : remove  -->  find (or search)


** page 104 line 13 from bottom

   > dictvar$Size()  -->  size()  : lowercase (see page 102) 


-----------------------------------------------------
Chapter 5

** page 118 line 7

   (1) shell short  -->  shell sort

   (2) 3.2k-1  -->  3 * 2 k-1


** page 133 line 2 from bottom

   43 goes to the third bin  -->  fourth bin


** page 136. title of Table 5.3

   assorting  -->  sorting


-----------------------------------------------------
Chapter 6

** page 142 line 6

   previous i-1 elements  -->  i+1   (see the below code)


** page 158. Figure 6.12

   (1)
   K mod 10  -->  K mod 5   (see the page 157 line 4 from bottom)

   (2) Hash Table 
   As K mod 5, 865 should assigned to bucket 0, not to bucket 1.
   Thus, bucket 0 : 865 // bucket 1 : 651


** page 157 last sentence

   zero elements are assigned to bucket 1, one element is assigned to bucket 5, 
   two elements are assigned to buckets 1 and 2, and three elements are assigned to bucket 3.
   (* not exist bucket 5)

   -->

   one element is assigned to bucket 0, 1 and 4, two elements are assigned to buckets 2,
   and three elements are assigned to bucket 3.


** page 160 line 11 from bottom

   As a first step, ...... third slot  -->  slot 3   (see the figure 6.15)


-----------------------------------------------------
Chapter 7

** page 171 line 6 from bottom

   log2bi  -->  'i' maybe subscripted. It's because of the word 'bi block'.


** page 172. Figure 7.4

   right bottom cells : 15, 17, 42  -->  69, 75, 89


** page 174. Figure 7.6

   Kn+1  -->  Kn  (see the below sentence)


** page 177. tttnode <- function()

   node$lvalue <- lvalue   # Node Value  -->  left Node Value
   node$center <- NULL     # left children key  -->  center ......


** page 185 line 12

   key of n  -->  N


** page 185 line 7 from bottom

   llist <- new.env(parent=create_emptyenv())   # runtime error

   -->  parent=emptyenv()


** page 188 line 3 from bottom

   In Figure 7.19, the deletion of key 68  -->  In Figure 7.20


** page 190. Table 7.1

   title of Table 7.1 is equal to title of Figure 7.21
   maybe title of Table 7.1 is missing


** page 190 line 2 from bottom

   2S  ->  S


-----------------------------------------------------
